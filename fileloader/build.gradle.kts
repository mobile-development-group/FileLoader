import java.util.Properties

plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
    id("maven-publish")
    id("signing")
}

android {
    namespace = "com.mdgroup.fileloader"
    compileSdk = 34

    defaultConfig {
        minSdk = 24
    }

    kotlinOptions {
        jvmTarget = "1.8"
    }

    // Include sources and javadoc .jar files as secondary artifacts
    publishing {
        singleVariant("release") {
            withSourcesJar()
            withJavadocJar()
        }
    }
}

dependencies {

    implementation("androidx.core:core-ktx:1.12.0")
    api("androidx.work:work-runtime-ktx:2.9.0")

}

// Configure the maven-publish plugin.
publishing {
    publications {
        // This says: defer this block until all of the other stuff has run first.
        // This is required since components["release"] is generated by the Android
        // plugin in `afterEvaluate` itself, which forces us to do the same.
        afterEvaluate {
            // Create a new publication called "release". The maven-publish plugin
            // creates tasks named publish${name}PublicationTo${target}, where
            // ${name} is a capitalized form of the name and ${target} is an output
            // repository. By default a MavenLocal target is automatically added,
            // which outputs to ~/.m2/repository.
            create<MavenPublication>("release") {
                // Include all artifacts from the "release" component. This is the
                // .aar file along with the sources and javadoc .jars.
                from(components["release"])

                // Here we configure some properties of the publication (these are
                // automatically applied to the pom file). Your library will be
                // referenced as ${groupId}:${artifactId}.
                groupId = "io.github.mobile-development-group"
                artifactId = "fileloader"
                version = "1.0.4"

                // And here are some more properties that go into the pom file.
                // For a full list of required metadata fields, see:
                // https://central.sonatype.org/publish/requirements/#sufficient-metadata
                pom {
                    packaging = "aar"
                    name.set("fileloader")
                    description.set("Library for convenient downloading of files on Android")
                    url.set("https://github.com/mobile-development-group/fileloader")

                    licenses {
                        license {
                            name.set("The Apache License, Version 2.0")
                            url.set("http://www.apache.org/licenses/LICENSE-2.0.txt")
                        }
                    }

                    developers {
                        developer {
                            name.set("Mobile Development Group")
                            email.set("md101110group@gmail.com")
                        }
                    }

                    scm {
                        url.set(pom.url.get())
                        connection.set("scm:git:${url.get()}.git")
                        developerConnection.set("scm:git:${url.get()}.git")
                    }
                }
            }
        }
    }

    // Here we define some repositories that we can publish our outputs to.
    repositories {
        // Specifying that this is a custom maven repository.
        maven {
            // This is the name of the repo that is used as the value of ${target}
            // from above.
            name = "sonatype"

            url = uri("https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/")

            credentials {
                val localPropertiesFile = project.rootProject.file("local.properties")
                if (localPropertiesFile.exists() && localPropertiesFile.canRead()) {
                    val properties = Properties().apply {
                        load(localPropertiesFile.inputStream())
                    }

                    username = properties.getProperty("ossrhUsername")
                    password = properties.getProperty("ossrhPassword")
                } else {
                    username = System.getenv("OSSRH_USERNAME")
                    password = System.getenv("OSSRH_PASSWORD")
                }
            }
        }
    }
}

// Configure the signing plugin.
signing {
    // Use the external gpg binary instead of the built-in PGP library.
    // This lets us use gpg-agent and avoid having to hard-code our PGP key
    // password somewhere.
    //
    // Note that you will need to add this in your ~/.gradle/gradle.properties:
    // signing.gnupg.keyName=<last 8 characters of your PGP key>
    //
    // Additionally, for users who have gpg instead of gpg2:
    // signing.gnupg.useLegacyGpg=true
    val localPropertiesFile = project.rootProject.file("local.properties")
    if (localPropertiesFile.exists() && localPropertiesFile.canRead()) {
        val properties = Properties().apply {
            load(localPropertiesFile.inputStream())
        }

        val defaultKeyId = properties.getProperty("signing.keyId")
        val secretKey = properties.getProperty("signing.key")
        val password = properties.getProperty("signing.password")

        useInMemoryPgpKeys(defaultKeyId, secretKey, password)
    } else {
        val defaultKeyId = System.getenv("SIGNING_KEY_ID")
        val secretKey = System.getenv("SIGNING_KEY")
        val password = System.getenv("SIGNING_PASSWORD")

        useInMemoryPgpKeys(defaultKeyId, secretKey, password)
//        useGpgCmd()
    }

    // Since the publication itself was created in `afterEvaluate`, we must
    // do the same here.
    afterEvaluate {
        // This adds a signing stage to the publish task in-place (so we keep
        // using the same task name; it just also performs signing now).
        sign(publishing.publications["release"])
    }
}